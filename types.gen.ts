// This file is auto-generated by @hey-api/openapi-ts

export type AddScopeMemberRequest = {
    /**
     * The GitHub login of the user to add to the scope.
     */
    githubLogin: string;
};

export type Authorization = {
    /**
     * The authorization code.
     */
    code: string;
    /**
     * The permissions that the token will have.
     */
    permissions: Array<Permission>;
    /**
     * The date and time until which the authorization can be approved / exchanged.
     */
    expiresAt: string;
};

export type AuthorizationExchangeRequest = {
    /**
     * The token that can be used to exchange for a device token after the authorization has been approved.
     */
    exchangeToken: string;
    /**
     * The verifier that was used to generate the challenge.
     */
    verifier: string;
};

export type AuthorizationExchangeResponse = {
    /**
     * The device token that can be used to authenticate requests.
     */
    token: string;
    user: (User & unknown);
};

export type CreateAuthorizationRequest = {
    /**
     * The challenge that will later be needed to retrieve the token after authorization.
     */
    challenge: string;
    /**
     * The permissions that the token will have.
     */
    permissions?: Array<Permission>;
};

export type CreateAuthorizationResponse = {
    /**
     * The URL that the user should visit to approve the authorization.
     */
    verificationUrl?: string;
    /**
     * The authorization code that the user can manually enter if they can not directly visit the link.
     */
    code: string;
    /**
     * The token that can be used to exchange for a device token after the authorization has been approved.
     */
    exchangeToken: string;
    /**
     * The number of seconds that should be waited between polling the status of the authorization.
     */
    pollInterval: number;
    /**
     * The date and time until which the authorization can be approved / exchanged.
     */
    expiresAt: string;
};

export type CreatePackageRequest = {
    package: PackageName;
};

export type CreateScopeRequest = {
    scope?: ScopeName;
};

export type Dependency = {
    /**
     * The kind of dependency.
     */
    kind: 'jsr' | 'npm';
    /**
     * The fully qualified name of the dependency.
     */
    name: string;
    /**
     * The semver constraint of the dependency.
     */
    constraint: string;
    /**
     * The path being imported from the dependency. This may be the empty string if the "default entrypoint" is being imported.
     */
    path: string;
};

/**
 * The kind of dependency.
 */
export type kind = 'jsr' | 'npm';

export type Dependent = {
    scope: ScopeName;
    name: PackageName;
    versions?: Array<Version>;
    /**
     * The total number of versions of the package.
     */
    totalVersions: number;
};

export type Error = {
    /**
     * The error code.
     */
    code: string;
    /**
     * The error message.
     */
    message: string;
};

export type GitHubRepository = {
    /**
     * The GitHub user / organization of the repository.
     */
    owner?: string;
    /**
     * The GitHub repository name.
     */
    name?: string;
};

export type Package = {
    scope: ScopeName;
    name: PackageName;
    /**
     * The description of the package.
     */
    description: string;
    runtimeCompat?: RuntimeCompat;
    /**
     * The date and time when the package was created.
     */
    createdAt: string;
    /**
     * The date and time when the package was last updated.
     */
    updatedAt: string;
    githubRepository?: GitHubRepository;
    score?: number;
};

/**
 * The name of a package.
 */
export type PackageName = string;

export type PackageScore = {
    hasReadme: boolean;
    hasReadmeExamples: boolean;
    allEntrypointsDocs: boolean;
    percentageDocumentedSymbols: number;
    allFastCheck: boolean;
    hasProvenance: boolean;
    hasDescription: boolean;
    atLeastOneRuntimeCompatible: boolean;
    multipleRuntimesCompatible: boolean;
    total?: number;
};

export type PackageVersion = {
    scope: ScopeName;
    package?: PackageName;
    version: Version;
    /**
     * Whether the version has been yanked.
     */
    yanked: boolean;
    /**
     * The date and time when the package version was created.
     */
    createdAt: string;
    /**
     * The date and time when the package version was last updated.
     */
    updatedAt: string;
    /**
     * Rekor log ID for the published package version.
     */
    rekorLogId?: string;
};

export type Permission = {
    /**
     * The permission name.
     */
    permission: 'package/publish';
    scope: ScopeName;
} | {
    /**
     * The permission name.
     */
    permission: 'package/publish';
    scope: ScopeName;
    package: PackageName;
} | {
    /**
     * The permission name.
     */
    permission: 'package/publish';
    scope: ScopeName;
    package: PackageName;
    version: Version;
    /**
     * The SHA256 hash of the tarball.
     */
    tarballHash: string;
};

/**
 * The permission name.
 */
export type permission = 'package/publish';

export type PublishingTask = {
    /**
     * The ID of the publishing task.
     */
    id: string;
    /**
     * The status of the publishing task.
     */
    status: 'pending' | 'processing' | 'processed' | 'success' | 'failure';
    error: {
        /**
         * The error code.
         */
        code?: string;
        /**
         * The error message.
         */
        message?: string;
    } | null;
    userId: (UserId & null);
    packageScope: ScopeName;
    packageName: PackageName;
    packageVersion: Version;
    /**
     * The date and time when the publishing task was created.
     */
    createdAt: string;
    /**
     * The date and time when the publishing task was last updated.
     */
    updatedAt: string;
};

/**
 * The status of the publishing task.
 */
export type status = 'pending' | 'processing' | 'processed' | 'success' | 'failure';

export type RuntimeCompat = {
    /**
     * Whether the package is compatible with web browsers.
     */
    browser?: (boolean) | null;
    /**
     * Whether the package is compatible with Deno.
     */
    deno?: (boolean) | null;
    /**
     * Whether the package is compatible with Node.js.
     */
    node?: (boolean) | null;
    /**
     * Whether the package is compatible with workerd.
     */
    workerd?: (boolean) | null;
    /**
     * Whether the package is compatible with Bun.
     */
    bun?: (boolean) | null;
};

export type Scope = {
    scope: ScopeName;
    creator?: User;
    quotas?: {
        /**
         * The number of packages in the scope.
         */
        packageUsage?: number;
        /**
         * The maximum number of packages allowed in the scope.
         */
        packageLimit?: number;
        /**
         * The number of new packages created in the scope in the last week.
         */
        newPackagePerWeekUsage?: number;
        /**
         * The maximum number of new packages allowed to be created in the scope in a week.
         */
        newPackagePerWeekLimit?: number;
        /**
         * The number of times packages in the scope have been published in the last week.
         */
        publishAttemptsPerWeekUsage?: number;
        /**
         * The maximum number of times packages in the scope can be published in a week.
         */
        publishAttemptsPerWeekLimit?: number;
    };
    /**
     * Whether to verify the actor of a GitHub Actions run when authenticating publishing with a GitHub Actions OIDC token.
     */
    ghActionsVerifyActor?: boolean;
    /**
     * Whether to require publishing from a CI environment. This disables publishing from a local environment.
     */
    requirePublishingFromCI?: boolean;
    /**
     * The date and time when the scope was created.
     */
    createdAt: string;
    /**
     * The date and time when the scope was last updated.
     */
    updatedAt: string;
};

export type ScopeInvite = {
    scope: ScopeName;
    targetUser: (User & unknown);
    inviter: (User & unknown);
    /**
     * The date and time when the invite was created.
     */
    createdAt: string;
    /**
     * The date and time when the invite was last updated.
     */
    updatedAt: string;
};

export type ScopeMember = {
    scope: ScopeName;
    user: User;
    /**
     * Whether the user is an admin of the scope.
     */
    isAdmin: boolean;
    /**
     * The date and time when the user was added to the scope.
     */
    createdAt: string;
    /**
     * The date and time when the scope member roles were last updated.
     */
    updatedAt: string;
};

/**
 * The name of a scope. This must not be @ prefixed.
 */
export type ScopeName = string;

export type Stats = {
    /**
     * The newest packages.
     */
    newest: Array<Package>;
    /**
     * The recently uploaded package versions.
     */
    updated: Array<PackageVersion>;
    /**
     * The featured packages
     */
    featured: Array<Package>;
};

export type UpdatePackageRequest = {
    /**
     * The description of the package.
     */
    description: string;
} | {
    githubRepository: {
        /**
         * The GitHub user / organization of the repository.
         */
        owner: string;
        /**
         * The GitHub repository name.
         */
        repo: string;
    } | null;
} | {
    runtimeCompat: RuntimeCompat;
} | {
    /**
     * Whether this package should be archived or not.
     */
    isArchived: boolean;
};

export type UpdatePackageVersionRequest = {
    /**
     * Whether the version is yanked or not.
     */
    yanked: boolean;
};

export type UpdateScopeMemberRequest = {
    /**
     * Whether the user should be an admin of the scope.
     */
    isAdmin: boolean;
};

export type UpdateScopeRequest = {
    /**
     * Whether to verify the actor of a GitHub Actions run when authenticating publishing with a GitHub Actions OIDC token.
     */
    ghActionsVerifyActor: boolean;
} | {
    /**
     * Whether to require publishing from a CI environment. This disables publishing from a local environment.
     */
    requirePublishingFromCI: boolean;
};

export type User = {
    id: UserId;
    /**
     * The user's display name.
     */
    name: string;
    /**
     * The user's email address.
     */
    email?: string;
    /**
     * The URL to the user's avatar.
     */
    avatarUrl: string;
    /**
     * The user's GitHub ID.
     */
    githubId?: number;
    /**
     * Whether the user is blocked from using the registry.
     */
    isBlocked?: boolean;
    /**
     * Whether the user is a staff member.
     */
    isStaff?: boolean;
    /**
     * The number of scopes the user created.
     */
    scopeUsage?: number;
    /**
     * The maximum number of scopes the user can create.
     */
    scopeLimit?: number;
    /**
     * The number of invites pending for the user.
     */
    inviteCount?: number;
    /**
     * The date and time when the user profile was created.
     */
    createdAt: string;
    /**
     * The date and time when the user profile was last updated.
     */
    updatedAt: string;
};

/**
 * The ID of a user.
 */
export type UserId = string;

/**
 * A semantic version.
 */
export type Version = string;

export type CreateScopeData = {
    /**
     * Scope properties
     */
    body: CreateScopeRequest;
};

export type CreateScopeResponse = (Scope);

export type CreateScopeError = (Error);

export type GetScopeData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type GetScopeResponse = (Scope);

export type GetScopeError = (Error);

export type UpdateScopeData = {
    /**
     * Scope properties
     */
    body: UpdateScopeRequest;
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type UpdateScopeResponse = (Scope);

export type UpdateScopeError = (Error);

export type DeleteScopeData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type DeleteScopeResponse = (void);

export type DeleteScopeError = (Error);

export type ListScopeMembersData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type ListScopeMembersResponse = (Array<ScopeMember>);

export type ListScopeMembersError = (Error);

export type AddScopeMemberData = {
    /**
     * Scope member properties
     */
    body: AddScopeMemberRequest;
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type AddScopeMemberResponse = (ScopeInvite);

export type AddScopeMemberError = (Error);

export type UpdateScopeMemberData = {
    /**
     * Scope member properties
     */
    body: UpdateScopeMemberRequest;
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The ID of the user
         */
        userId: UserId;
    };
};

export type UpdateScopeMemberResponse = (ScopeMember);

export type UpdateScopeMemberError = (Error);

export type RemoveScopeMemberData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The ID of the user
         */
        userId: UserId;
    };
};

export type RemoveScopeMemberResponse = (void);

export type RemoveScopeMemberError = (Error);

export type ListScopeInvitesData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type ListScopeInvitesResponse = (Array<ScopeInvite>);

export type ListScopeInvitesError = (Error);

export type DeleteScopeInviteData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The ID of the user
         */
        userId: UserId;
    };
};

export type DeleteScopeInviteResponse = (void);

export type DeleteScopeInviteError = (Error);

export type ListPackagesData = {
    query?: {
        /**
         * The maximum number of packages to return
         */
        limit?: number;
        /**
         * The page number of packages to return
         */
        page?: number;
        /**
         * The search query
         */
        query?: string;
    };
};

export type ListPackagesResponse = ({
    items?: Array<Package>;
    total?: number;
});

export type ListPackagesError = (Error);

export type ListScopePackagesData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
    query?: {
        /**
         * The maximum number of packages to return
         */
        limit?: number;
        /**
         * The page number of packages to return
         */
        page?: number;
    };
};

export type ListScopePackagesResponse = ({
    items?: Array<Package>;
    total?: number;
});

export type ListScopePackagesError = (Error);

export type CreatePackageData = {
    /**
     * Package properties
     */
    body: CreatePackageRequest;
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type CreatePackageResponse = (Package);

export type CreatePackageError = (Error);

export type GetPackageData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type GetPackageResponse = (Package);

export type GetPackageError = (Error);

export type UpdatePackageData = {
    /**
     * Package properties
     */
    body: UpdatePackageRequest;
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type UpdatePackageResponse = (Package);

export type UpdatePackageError = (Error);

export type DeletePackageData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type DeletePackageResponse = (void);

export type DeletePackageError = (Error);

export type ListPackageDependentsData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
    query?: {
        /**
         * The maximum number of dependents to return
         */
        limit?: number;
        /**
         * The page number of dependents to return
         */
        page?: number;
        /**
         * The maximum number of versions per package to return
         */
        versions_per_package_limit?: number;
    };
};

export type ListPackageDependentsResponse = ({
    items?: Array<Dependent>;
    total?: number;
});

export type ListPackageDependentsError = (Error);

export type GetPackageScoreData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type GetPackageScoreResponse = (PackageScore);

export type GetPackageScoreError = (Error);

export type ListPackageVersionsData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type ListPackageVersionsResponse = (Array<PackageVersion>);

export type ListPackageVersionsError = (Error);

export type GetPackageVersionData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The version of the package
         */
        version: Version;
    };
};

export type GetPackageVersionResponse = (PackageVersion);

export type GetPackageVersionError = (Error);

export type CreatePackageVersionData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The version of the package
         */
        version: Version;
    };
    query: {
        /**
         * The path to the config file
         */
        config: string;
    };
};

export type CreatePackageVersionResponse = (PublishingTask);

export type CreatePackageVersionError = (Error);

export type UpdatePackageVersionData = {
    /**
     * Package version properties
     */
    body: UpdatePackageVersionRequest;
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The version of the package
         */
        version: Version;
    };
};

export type UpdatePackageVersionResponse = (PackageVersion);

export type UpdatePackageVersionError = (Error);

export type ListDependenciesData = {
    path: {
        /**
         * The name of the package
         */
        package: PackageName;
        /**
         * The name of the scope
         */
        scope: ScopeName;
        /**
         * The version of the package
         */
        version: Version;
    };
};

export type ListDependenciesResponse = (Array<Dependency>);

export type ListDependenciesError = (Error);

export type GetSelfUserResponse = (User);

export type GetSelfUserError = (Error);

export type ListSelfUserScopesResponse = (Array<Scope>);

export type ListSelfUserScopesError = (Error);

export type GetSelfUserScopeMemberData = {
    path: {
        /**
         * The name of the scope
         */
        scope: ScopeName;
    };
};

export type GetSelfUserScopeMemberResponse = (ScopeMember);

export type GetSelfUserScopeMemberError = (Error);

export type ListSelfUserInvitesResponse = (Array<ScopeInvite>);

export type ListSelfUserInvitesError = (Error);

export type AcceptScopeInviteData = {
    path: {
        /**
         * The name of the scope to accept the invite for
         */
        scope: ScopeName;
    };
};

export type AcceptScopeInviteResponse = (ScopeMember);

export type AcceptScopeInviteError = (Error);

export type DeclineScopeInviteData = {
    path: {
        /**
         * The name of the scope to decline the invite for
         */
        scope: ScopeName;
    };
};

export type DeclineScopeInviteResponse = (void);

export type DeclineScopeInviteError = (Error);

export type GetUserData = {
    path: {
        /**
         * The ID of the user
         */
        id: UserId;
    };
};

export type GetUserResponse = (User);

export type GetUserError = (Error);

export type ListUserScopesData = {
    path: {
        /**
         * The ID of the user
         */
        id: UserId;
    };
};

export type ListUserScopesResponse = (Array<Scope>);

export type ListUserScopesError = (Error);

export type CreateAuthorizationData = {
    /**
     * Authorization properties
     */
    body: CreateAuthorizationRequest;
};

export type CreateAuthorizationResponse2 = (CreateAuthorizationResponse);

export type CreateAuthorizationError = (Error);

export type GetAuthorizationDetailsData = {
    path: {
        /**
         * The code of the authorization
         */
        code: string;
    };
};

export type GetAuthorizationDetailsResponse = (Authorization);

export type GetAuthorizationDetailsError = (Error);

export type ApproveAuthorizationData = {
    path: {
        /**
         * The code of the authorization
         */
        code: string;
    };
};

export type ApproveAuthorizationResponse = (void);

export type ApproveAuthorizationError = (Error);

export type DenyAuthorizationData = {
    path: {
        /**
         * The code of the authorization
         */
        code: string;
    };
};

export type DenyAuthorizationResponse = (void);

export type DenyAuthorizationError = (Error);

export type ExchangeAuthorizationCodeData = {
    body: AuthorizationExchangeRequest;
};

export type ExchangeAuthorizationCodeResponse = (AuthorizationExchangeResponse);

export type ExchangeAuthorizationCodeError = (Error);

export type GetPublishingTaskData = {
    path: {
        /**
         * The ID of the publishing task
         */
        id: string;
    };
};

export type GetPublishingTaskResponse = (PublishingTask);

export type GetPublishingTaskError = (Error);

export type GetStatsResponse = (Stats);

export type GetStatsError = unknown;